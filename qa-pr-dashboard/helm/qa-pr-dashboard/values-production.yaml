# Production-ready values for FlowOps
# Usage: helm install qa-pr-dashboard . -f values-production.yaml

# Image configuration - use specific tags in production
image:
  frontend:
    repository: amitngm/qa-pr-dashboard-frontend
    pullPolicy: Always
    tag: "latest"  # In production, use specific version tags like "1.0.0"
  api:
    repository: amitngm/qa-pr-dashboard-api
    pullPolicy: Always
    tag: "latest"  # In production, use specific version tags like "1.0.0"

# Use image pull secrets if pulling from private registry
imagePullSecrets:
  - name: docker-registry-secret  # Create this secret if needed

# Replica count - use autoscaling in production
replicaCount: 3

# Service Account for RBAC
serviceAccount:
  create: true
  annotations:
    eks.amazonaws.com/role-arn: ""  # If using AWS EKS IRSA
  name: qa-pr-dashboard-sa

# Pod annotations for monitoring, etc.
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8000"
  prometheus.io/path: "/metrics"

# Security Context - run as non-root user
podSecurityContext:
  fsGroup: 1001
  runAsNonRoot: true
  runAsUser: 1001

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false  # Set to true if app doesn't need write access
  runAsNonRoot: true
  runAsUser: 1001

# Service configuration
service:
  frontend:
    type: ClusterIP  # Use LoadBalancer if needed, or NodePort for bare metal
    port: 3000
    targetPort: 3000
    annotations: {}
  api:
    type: ClusterIP
    port: 8000
    targetPort: 8000
    annotations: {}

# Ingress configuration - ENABLE for production
ingress:
  enabled: true
  className: "nginx"  # or "traefik", "istio", etc.
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"  # For TLS
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "300"
  hosts:
    - host: qa-pr-dashboard.example.com  # Change to your domain
      paths:
        - path: /
          pathType: Prefix
        - path: /api
          pathType: Prefix
  tls:
    - secretName: qa-pr-dashboard-tls
      hosts:
        - qa-pr-dashboard.example.com  # Change to your domain

# Resource limits and requests - PRODUCTION RECOMMENDATIONS
resources:
  frontend:
    limits:
      cpu: 1000m      # 1 CPU
      memory: 512Mi   # 512 MB
    requests:
      cpu: 200m       # 0.2 CPU
      memory: 256Mi   # 256 MB
  api:
    limits:
      cpu: 2000m      # 2 CPU
      memory: 2Gi     # 2 GB
    requests:
      cpu: 500m       # 0.5 CPU
      memory: 512Mi   # 512 MB

# Autoscaling - ENABLE for production
autoscaling:
  enabled: true
  minReplicas: 3      # Minimum replicas for HA
  maxReplicas: 10     # Maximum replicas
  targetCPUUtilizationPercentage: 70    # Scale at 70% CPU
  targetMemoryUtilizationPercentage: 80  # Scale at 80% memory
  # Optional: Pod disruption budget
  podDisruptionBudget:
    minAvailable: 2   # Always keep at least 2 pods available

# Node selection (optional)
nodeSelector:
  workload-type: application  # Adjust based on your node labels

# Affinity rules - spread pods across nodes for HA
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - qa-pr-dashboard
          topologyKey: kubernetes.io/hostname

# Tolerations (optional)
tolerations: []
  # - key: "workload"
  #   operator: "Equal"
  #   value: "application"
  #   effect: "NoSchedule"

# Environment variables - PRODUCTION CONFIGURATION
env:
  api:
    NODE_ENV: production
    PORT: "8000"
    MONGODB_URI: "mongodb://mongodb-service.qa-pr-dashboard.svc.cluster.local:27017"
    DB_NAME: "qa_pr_dashboard"
    SKIP_MONGO: "false"
    # Add logging level
    LOG_LEVEL: "info"
    # Add rate limiting
    RATE_LIMIT_WINDOW_MS: "900000"  # 15 minutes
    RATE_LIMIT_MAX_REQUESTS: "100"
  
  frontend:
    NODE_ENV: production
    PORT: "3000"
    API_URL: "http://qa-pr-dashboard-api:8000/api"
    NEXT_PUBLIC_API_URL: "https://qa-pr-dashboard.example.com/api"  # Public API URL
    # Add feature flags
    NEXT_PUBLIC_ENABLE_ANALYTICS: "true"

# Secrets - CREATE THESE SEPARATELY using kubectl or external secrets
# DO NOT commit secrets to git!
secrets:
  github:
    token: ""  # Create secret: kubectl create secret generic qa-pr-dashboard-secrets --from-literal=github-token=xxx
  jira:
    baseUrl: ""
    email: ""
    apiToken: ""
    projectKey: ""

# MongoDB configuration
mongodb:
  enabled: false  # Set to true if you want to deploy MongoDB with the chart
  serviceName: "mongodb-service"
  port: 27017
  # For production, use external managed MongoDB (Atlas, AWS DocumentDB, etc.)
  # MONGODB_URI should point to external service
  # MongoDB resource configuration (if deploying with chart)
  resources:
    requests:
      cpu: 500m
      memory: 2Gi      # Increased from default
    limits:
      cpu: 2000m
      memory: 4Gi      # Increased from default
  # Storage configuration
  storage:
    size: 100Gi        # Increased storage size
    storageClass: ""   # Use default storage class or specify
    accessMode: ReadWriteOnce
  # Replica set configuration (for HA)
  replicaCount: 3      # For production HA setup
  persistence:
    enabled: true
    size: 100Gi
    storageClass: ""

# Health checks - PRODUCTION CONFIGURATION
livenessProbe:
  frontend:
    httpGet:
      path: /
      port: 3000
      scheme: HTTP
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  
  api:
    httpGet:
      path: /api/health
      port: 8000
      scheme: HTTP
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1

readinessProbe:
  frontend:
    httpGet:
      path: /
      port: 3000
      scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1
  
  api:
    httpGet:
      path: /api/health
      port: 8000
      scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1

# Startup probe (helps with slow-starting apps)
startupProbe:
  frontend:
    httpGet:
      path: /
      port: 3000
      scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
    successThreshold: 1
  
  api:
    httpGet:
      path: /api/health
      port: 8000
      scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
    successThreshold: 1

# Network policies (optional, for enhanced security)
networkPolicy:
  enabled: false
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 3000
    - from:
        - podSelector:
            matchLabels:
              component: api
      ports:
        - protocol: TCP
          port: 8000

# ServiceMonitor for Prometheus (if using Prometheus Operator)
serviceMonitor:
  enabled: false
  interval: 30s
  scrapeTimeout: 10s


